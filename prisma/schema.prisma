generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Property {
  id          String   @id @default(cuid())
  name        String
  items       Int
  volume      Float    @default(0)
  floorPrice  Float
  image       String
  category    String
  verified    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  description String?
  nfts        NFT[]
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("properties")
}

model NFT {
  id            String       @id @default(cuid())
  name          String
  itemNumber    Int
  image         String
  price         Float
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  propertyId    String?      
  ownerId       String?      
  isListed      Boolean      @default(false)
  landListingId String?      @map("land_listing_id")
  landListing   LandListing? @relation("LandListingToNFTs", fields: [landListingId], references: [id], onDelete: Cascade)
  owner         User?        @relation(fields: [ownerId], references: [id])
  property      Property?    @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  offers        Offer[]
  trades        Trade[]
  evmCollectionTokens EvmCollectionToken[]

  @@unique([propertyId, itemNumber])
  @@index([propertyId])
  @@index([ownerId])
  @@index([isListed])
  @@map("nfts")
}

model User {
  id                String             @id @default(uuid())
  username          String?            @unique @db.VarChar(50)
  email             String?            @unique @db.VarChar(255)
  passwordHash      String?            @map("password_hash") @db.VarChar(255)
  fullName          String?            @map("full_name") @db.VarChar(100)
  addressLine1      String?            @map("address_line1") @db.VarChar(255)
  addressLine2      String?            @map("address_line2") @db.VarChar(255)
  city              String?            @db.VarChar(100)
  stateProvince     String?            @map("state_province") @db.VarChar(100)
  postalCode        String?            @map("postal_code") @db.VarChar(20)
  country           String?            @db.VarChar(100)
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @updatedAt @map("updated_at")
  signInNonce       String?            @map("sign_in_nonce") @db.VarChar(255)
  evmAddress        String?            @unique @map("evm_address") @db.VarChar(42)
  dateOfBirth       DateTime?          @map("date_of_birth") @db.Date
  govIdRef          String?            @map("gov_id_ref")
  govIdType         String?            @map("gov_id_type") @db.VarChar(50)
  kycVerified       Boolean            @default(false) @map("kyc_verified")
  phone             String?            @db.VarChar(20)
  sofDocRef         String?            @map("sof_doc_ref")
  isAdmin           Boolean            @default(false) @map("is_admin")
  kycUpdateRequests KycUpdateRequest[]
  landListings      LandListing[]
  nfts              NFT[]
  offersMade        Offer[]            @relation("OffersMade")
  properties        Property[]
  tradesBought      Trade[]            @relation("TradesBought")
  tradesSold        Trade[]            @relation("TradesSold")
  watchlist         Watchlist[]        @relation("UserWatchlist")

  @@index([evmAddress], map: "idx_users_evm_address")
  @@index([username])
  @@index([email])
  @@map("users")
}

model KycUpdateRequest {
  id         String   @id @default(cuid())
  userId     String
  status     String   @default("PENDING")
  changes    Json
  adminNotes String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@map("kyc_update_requests")
}

model Offer {
  id        String    @id @default(cuid())
  nftId     String
  offererId String
  price     Float
  status    String    @default("ACTIVE")
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  nft       NFT       @relation(fields: [nftId], references: [id], onDelete: Cascade)
  offerer   User      @relation("OffersMade", fields: [offererId], references: [id], onDelete: Cascade)

  @@index([nftId])
  @@index([offererId])
  @@index([status])
  @@map("offers")
}

model Trade {
  id        String   @id @default(cuid())
  nftId     String
  buyerId   String
  sellerId  String
  price     Float
  timestamp DateTime @default(now())
  buyer     User     @relation("TradesBought", fields: [buyerId], references: [id], onDelete: Cascade)
  nft       NFT      @relation(fields: [nftId], references: [id], onDelete: Cascade)
  seller    User     @relation("TradesSold", fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([nftId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([timestamp])
  @@map("trades")
}

model Watchlist {
  id           String      @id @default(cuid())
  userId       String
  collectionId String
  createdAt    DateTime    @default(now())
  user         User        @relation("UserWatchlist", fields: [userId], references: [id], onDelete: Cascade)
  collection   LandListing @relation("WatchlistedCollections", fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([userId, collectionId])
  @@index([userId])
  @@index([collectionId])
  @@map("watchlist")
}

model LandListing {
  id                     String      @id @default(cuid())
  userId                 String
  titleDeedFileRef       String?     @map("title_deed_file_ref")
  deedNumber             String?
  deedType               String?
  grantorName            String?
  granteeName            String?
  deedDate               DateTime?   @db.Date
  titleCertFileRef       String?     @map("title_cert_file_ref")
  certNumber             String?
  certIssueDate          DateTime?   @db.Date
  certExpiryDate         DateTime?   @db.Date
  encumbranceFileRef     String?     @map("encumbrance_file_ref")
  encumbranceId          String?
  encumbrancePeriodStart DateTime?   @db.Date
  encumbrancePeriodEnd   DateTime?   @db.Date
  parcelNumber           String?
  registryVolume         String?
  registryPage           String?
  surveyPlanFileRef      String?     @map("survey_plan_file_ref")
  surveyPlanNumber       String?
  surveyDate             DateTime?   @db.Date
  country                String?     @map("country")
  state                  String?     @map("state")
  localGovernmentArea    String?     @map("local_government_area")
  propertyAreaSqm        Float?      @map("property_area_sqm")
  latitude               String?
  longitude              String?
  gisFileRef             String?     @map("gis_file_ref")
  ownerName              String?
  govIdNumber            String?
  idIssueDate            DateTime?   @db.Date
  idExpiryDate           DateTime?   @db.Date
  idDocumentFileRef      String?     @map("id_document_file_ref")
  addressProofFileRef    String?     @map("address_proof_file_ref")
  kycStatus              String?     @default("PENDING")
  titleSearchFileRef     String?     @map("title_search_file_ref")
  titleOpinionFileRef    String?     @map("title_opinion_file_ref")
  recordedInstruments    String?
  docHash                String? // Existing, keeping for now
  ipfsUri                String? // Existing, will be superseded by metadataUri for on-chain metadata
  // Removed mintTimestamp to avoid duplication with Ethereum fields
  tokenId                String? // Existing, might be superseded by mintAddress
  propertyDescription    String?
  propertyPhotosFileRef  String[]    @map("property_photos_file_ref")
  propertyValuation      String?     @map("property_valuation")
  propertyValuationFileRef String?   @map("property_valuation_file_ref")
  valuationDate          DateTime?   @db.Date
  zoningClassification   String?
  zoningComplianceFileRef String?    @map("zoning_compliance_file_ref")
  additionalNotes        String?
  status                 String?     @default("DRAFT") // Example: DRAFT, ACTIVE, SOLD, DELISTED
  nftTitle               String?     @map("nft_title")
  nftDescription         String?
  listingPrice           Decimal?    @db.Decimal(18, 8)
  priceCurrency          String?     @default("SOL")
  nftImageFileRef        String?     @map("nft_image_file_ref")
  nftCollectionSize      Int?        @default(100) @map("nft_collection_size") // Typically 1 for a unique NFT
  slug                   String?     @unique

  // --- Ethereum NFT Integration Fields ---
  contractAddress        String?
  collectionId           BigInt? // Changed from Int?
  mainTokenId            BigInt? // Changed from Int?
  metadataUri            String? // For collection-level metadata
  evmOwnerAddress        String?     @map("evm_owner_address") // Current owner's Ethereum address
  isListedForSale        Boolean     @default(false) @map("is_listed_for_sale")
  listingPriceEth        Float?      @map("listing_price_eth") // Price in ETH if listed on our platform
  mintTransactionHash    String?     @map("mint_transaction_hash") // Transaction hash of the mint transaction
  mintTimestamp          DateTime?   @map("mint_timestamp") // When the NFT was minted
  mintStatus             String?     @default("NOT_STARTED") @map("mint_status") // NOT_STARTED, PENDING, COMPLETED, FAILED
  // --- End Ethereum NFT Integration Fields ---

  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  individualNfts         NFT[]       @relation("LandListingToNFTs")
  watchlistedBy          Watchlist[] @relation("WatchlistedCollections")
  evmCollectionTokens    EvmCollectionToken[]
  user                   User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([contractAddress])
  @@index([collectionId])
  @@index([mainTokenId])
  @@index([evmOwnerAddress])
  @@index([isListedForSale])
  @@index([mintStatus])
  @@map("land_listings")
}

model EvmCollectionToken {
  id                String       @id @default(cuid())
  landListingId     String       @map("land_listing_id")
  nftId             String?      @map("nft_id")
  tokenId           Int          @map("token_id")
  isMainToken       Boolean      @default(false) @map("is_main_token")
  tokenURI          String       @map("token_uri")
  ownerAddress      String?      @map("owner_address")
  mintTransactionHash String?    @map("mint_transaction_hash")
  mintTimestamp     DateTime?    @map("mint_timestamp")
  mintStatus        String       @default("NOT_STARTED") @map("mint_status") // NOT_STARTED, PENDING, COMPLETED, FAILED
  isListed          Boolean      @default(false) @map("is_listed")
  listingPrice      Float?       @map("listing_price")
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  landListing       LandListing  @relation(fields: [landListingId], references: [id], onDelete: Cascade)
  nft               NFT?         @relation(fields: [nftId], references: [id], onDelete: SetNull)
  
  @@index([landListingId])
  @@index([nftId])
  @@index([tokenId])
  @@index([isMainToken])
  @@index([ownerAddress])
  @@index([mintStatus])
  @@index([isListed])
  @@map("evm_collection_tokens")
}
