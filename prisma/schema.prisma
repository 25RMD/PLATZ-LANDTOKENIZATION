generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Property {
  id          String   @id @default(cuid())
  name        String
  items       Int
  volume      Float    @default(0)
  floorPrice  Float
  image       String
  category    String
  verified    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  description String?
  nfts        NFT[]
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("properties")
}

model NFT {
  id                  String               @id @default(cuid())
  name                String
  itemNumber          Int
  image               String
  price               Float
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  propertyId          String?
  ownerId             String?
  isListed            Boolean              @default(false)
  landListingId       String?              @map("land_listing_id")
  evmCollectionTokens EvmCollectionToken[]
  landListing         LandListing?         @relation("LandListingToNFTs", fields: [landListingId], references: [id], onDelete: Cascade)
  owner               User?                @relation("UserOwnedNFTs", fields: [ownerId], references: [id])
  property            Property?            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  offers              Offer[]
  trades              Trade[]

  @@unique([propertyId, itemNumber])
  @@index([propertyId])
  @@index([ownerId])
  @@index([isListed])
  @@map("nfts")
}

model User {
  id                String             @id @default(uuid())
  username          String?            @unique @db.VarChar(50)
  email             String?            @unique @db.VarChar(255)
  passwordHash      String?            @map("password_hash") @db.VarChar(255)
  fullName          String?            @map("full_name") @db.VarChar(100)
  addressLine1      String?            @map("address_line1") @db.VarChar(255)
  addressLine2      String?            @map("address_line2") @db.VarChar(255)
  city              String?            @db.VarChar(100)
  stateProvince     String?            @map("state_province") @db.VarChar(100)
  postalCode        String?            @map("postal_code") @db.VarChar(20)
  country           String?            @db.VarChar(100)
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @updatedAt @map("updated_at")
  signInNonce       String?            @map("sign_in_nonce") @db.VarChar(255)
  evmAddress        String?            @unique @map("evm_address") @db.VarChar(42)
  dateOfBirth       DateTime?          @map("date_of_birth") @db.Date
  govIdRef          String?            @map("gov_id_ref")
  govIdType         String?            @map("gov_id_type") @db.VarChar(50)
  kycVerified       Boolean            @default(false) @map("kyc_verified")
  phone             String?            @db.VarChar(20)
  authType          String             @default("email") @map("auth_type") @db.VarChar(20)
  isAdmin           Boolean            @default(false) @map("is_admin")
  walletAddress     String?            @unique @map("wallet_address") @db.VarChar(42)
  accounts          Account[]
  sessions          Session[]
  kycUpdateRequests KycUpdateRequest[]
  landListings      LandListing[]
  nftBids           NftBid[]
  ownedNfts         NFT[]              @relation("UserOwnedNFTs")
  offersMade        Offer[]            @relation("OffersMade")
  offersReceived    Offer[]
  properties        Property[]
  tradesBought      Trade[]            @relation("TradesBought")
  tradesCreated     Trade[]            @relation("TradesCreated")
  tradesSold        Trade[]            @relation("TradesSold")
  watchlist         Watchlist[]        @relation("UserWatchlist")

  @@index([evmAddress], map: "idx_users_evm_address")
  @@index([username])
  @@index([email])
  @@map("users")
}

model KycUpdateRequest {
  id         String   @id @default(cuid())
  userId     String
  status     String   @default("PENDING")
  changes    Json
  adminNotes String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@map("kyc_update_requests")
}

model Offer {
  id        String    @id @default(cuid())
  nftId     String
  offererId String
  price     Float
  status    String    @default("ACTIVE")
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  userId    String?
  nft       NFT       @relation(fields: [nftId], references: [id], onDelete: Cascade)
  offerer   User      @relation("OffersMade", fields: [offererId], references: [id], onDelete: Cascade)
  User      User?     @relation(fields: [userId], references: [id])

  @@index([nftId])
  @@index([offererId])
  @@index([status])
  @@map("offers")
}

model Trade {
  id        String   @id @default(cuid())
  nftId     String
  buyerId   String
  sellerId  String
  price     Float
  timestamp DateTime @default(now())
  creatorId String?
  buyer     User     @relation("TradesBought", fields: [buyerId], references: [id], onDelete: Cascade)
  creator   User?    @relation("TradesCreated", fields: [creatorId], references: [id])
  nft       NFT      @relation(fields: [nftId], references: [id], onDelete: Cascade)
  seller    User     @relation("TradesSold", fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([nftId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([timestamp])
  @@index([creatorId])
  @@map("trades")
}

model Watchlist {
  id           String      @id @default(cuid())
  userId       String
  collectionId String
  createdAt    DateTime    @default(now())
  collection   LandListing @relation("WatchlistedCollections", fields: [collectionId], references: [id], onDelete: Cascade)
  user         User        @relation("UserWatchlist", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, collectionId])
  @@index([userId])
  @@index([collectionId])
  @@map("watchlist")
}

model LandListing {
  id                         String               @id @default(cuid())
  userId                     String
  titleDeedFileRef           String?              @map("title_deed_file_ref")
  deedNumber                 String?
  deedType                   String?
  grantorName                String?
  granteeName                String?
  deedDate                   DateTime?            @db.Date
  titleCertFileRef           String?              @map("title_cert_file_ref")
  certNumber                 String?
  certIssueDate              DateTime?            @map("cert_issue_date") @db.Date
  legalDescription           String?              @map("legal_description")
  parcelNumber               String?              @map("parcel_number")
  propertyAddress            String?              @map("property_address")
  city                       String?
  state                      String?
  zipCode                    String?              @map("zip_code")
  country                    String?
  latitude                   Float?
  longitude                  Float?
  propertyType               String?              @map("property_type")
  propertyAreaSqm            Float?               @map("property_area_sqm")
  propertyDescription        String?              @map("property_description")
  nftDescription             String?              @map("nft_description")
  listingTitle               String?              @map("listing_title")
  listingPrice               Float?               @map("listing_price")
  priceCurrency              String?              @map("price_currency")
  status                     String               @default("DRAFT")
  createdAt                  DateTime             @default(now()) @map("created_at")
  updatedAt                  DateTime             @updatedAt @map("updated_at")
  mintStatus                 String?              @map("mint_status")
  mintErrorReason            String?              @map("mint_error_reason")
  mintTimestamp              DateTime?            @map("mint_timestamp")
  mintTransactionHash        String?              @map("mint_transaction_hash")
  tokenId                    Int?                 @map("token_id")
  contractAddress            String?              @map("contract_address")
  collectionId               String?              @unique @map("collection_id")
  mainTokenId                String?              @map("main_token_id")
  collectionNftTitle         String?              @map("collection_nft_title")
  collectionMetadataUrl      String?              @map("collection_metadata_url")
  mainTokenMetadataUrl       String?              @map("main_token_metadata_url")
  childTokensBaseUrl         String?              @map("child_tokens_base_url")
  slug                       String?              @unique
  coverImageUrl              String?              @map("cover_image_url")
  nftTitle                   String?              @map("nft_title")
  nftImageFileRef            String?              @map("nft_image_file_ref")
  nftCollectionSize          Int?                 @default(10) @map("nft_collection_size")
  marketplaceListingId       Int?                 @map("marketplace_listing_id")
  marketplaceTransactionHash String?              @map("marketplace_transaction_hash")
  marketplaceListingError    String?              @map("marketplace_listing_error")
  nftImageIrysUri            String?              @map("nft_image_irys_uri")
  nftMetadataIrysUri         String?              @map("nft_metadata_irys_uri")
  localGovernmentArea        String?              @map("local_government_area")
  propertyValuation          String?              @map("property_valuation")
  zoningClassification       String?              @map("zoning_classification")
  creatorAddress             String?              @map("creator_address")
  evmCollectionTokens        EvmCollectionToken[] @relation("LandListingTokens")
  user                       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  nfts                       NFT[]                @relation("LandListingToNFTs")
  watchlist                  Watchlist[]          @relation("WatchlistedCollections")
  nftBids                    NftBid[]
  transactions               NftTransaction[]
  priceHistory               CollectionPriceHistory[] @relation("CollectionPriceHistory")

  @@index([userId])
  @@index([status])
  @@index([mintStatus])
  @@map("land_listings")
}

model EvmCollectionToken {
  id                  String      @id @default(cuid())
  landListingId       String      @map("land_listing_id")
  nftId               String?     @map("nft_id")
  tokenId             Int         @map("token_id")
  isMainToken         Boolean     @default(false) @map("is_main_token")
  tokenURI            String      @map("token_uri")
  ownerAddress        String?     @map("owner_address")
  mintTransactionHash String?     @map("mint_transaction_hash")
  mintTimestamp       DateTime?   @map("mint_timestamp")
  mintStatus          String      @default("NOT_STARTED") @map("mint_status")
  isListed            Boolean     @default(false) @map("is_listed")
  listingPrice        Float?      @map("listing_price")
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  landListing         LandListing @relation("LandListingTokens", fields: [landListingId], references: [id], onDelete: Cascade)
  nft                 NFT?        @relation(fields: [nftId], references: [id])

  @@index([landListingId])
  @@index([nftId])
  @@index([tokenId])
  @@index([isMainToken])
  @@index([ownerAddress])
  @@index([mintStatus])
  @@index([isListed])
  @@map("evm_collection_tokens")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model NftBid {
  id              String      @id @default(cuid())
  landListingId   String      @map("land_listing_id")
  tokenId         Int         @default(0) @map("token_id")
  bidderUserId    String      @map("bidder_user_id")
  bidAmount       Float       @map("bid_amount")
  bidStatus       String      @map("bid_status") @db.VarChar(20)
  transactionHash String?     @map("transaction_hash") @db.VarChar(66)
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")
  bidder          User        @relation(fields: [bidderUserId], references: [id])
  landListing     LandListing @relation(fields: [landListingId], references: [id])

  @@index([tokenId])
  @@index([landListingId])
  @@index([bidderUserId])
  @@index([bidStatus])
  @@map("nft_bids")
}

model NftTransaction {
  id              String      @id @default(cuid())
  landListingId   String      @map("land_listing_id")
  tokenId         Int         @map("token_id")
  fromAddress     String      @map("from_address") @db.VarChar(42)
  toAddress       String      @map("to_address") @db.VarChar(42)
  price           Float
  transactionHash String      @map("transaction_hash") @db.VarChar(66)
  transactionType String      @map("transaction_type") @db.VarChar(20)
  createdAt       DateTime    @default(now()) @map("created_at")
  landListing     LandListing @relation(fields: [landListingId], references: [id])

  @@map("nft_transactions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model CollectionPriceHistory {
  id                 String      @id @default(cuid())
  landListingId      String      @map("land_listing_id")
  priceType          String      @map("price_type") @db.VarChar(20) // 'FLOOR_PRICE', 'AVG_PRICE', 'BID_PLACED', 'BID_ACCEPTED', 'BID_REJECTED', 'SALE'
  price              Float
  previousPrice      Float?      @map("previous_price")
  changePercentage   Float?      @map("change_percentage")
  bidId              String?     @map("bid_id") // Reference to NftBid if this is bid-related
  transactionId      String?     @map("transaction_id") // Reference to NftTransaction if this is sale-related
  metadata           Json?       // Additional metadata about the price change
  createdAt          DateTime    @default(now()) @map("created_at")
  landListing        LandListing @relation("CollectionPriceHistory", fields: [landListingId], references: [id], onDelete: Cascade)

  @@index([landListingId])
  @@index([priceType])
  @@index([createdAt])
  @@map("collection_price_history")
}
